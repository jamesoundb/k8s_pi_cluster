---
# Playbook for joining a control plane node using prepared certificate data
# Usage: ansible-playbook -i inventory.yml playbooks/execute-join.yml -e "target_node=k8s-node-2"

- name: Join a control plane node using prepared certificate data
  hosts: "{{ target_node }}"
  become: true
  gather_facts: true
  vars:
    join_data_file: "/tmp/{{ target_node }}_join_data.txt"
  tasks:
    - name: Verify target node is defined
      fail:
        msg: "Please specify a target node with -e 'target_node=hostname'"
      when: target_node is not defined

    - name: Reset any previous Kubernetes configuration
      shell: kubeadm reset --force
      ignore_errors: true
      
    - name: Clean up any network interfaces and remnants
      shell: |
        ip link delete cni0 || true
        ip link delete flannel.1 || true
        rm -rf /etc/cni/net.d/* || true
        find /etc/kubernetes/pki/ -type f -not -path "*/.*" -delete || true
        rm -f /etc/kubernetes/kubelet.conf || true
        rm -rf /etc/kubernetes/manifests/* || true
      ignore_errors: true
      
    - name: Restart containerd
      systemd:
        name: containerd
        state: restarted
        
    - name: Kill any running kubelet processes first
      shell: pkill -9 -f kubelet || true
      ignore_errors: true
      
    - name: Wait briefly for processes to terminate
      pause:
        seconds: 2
        
    - name: Stop kubelet service
      systemd:
        name: kubelet
        state: stopped
      ignore_errors: true
      
    - name: Wait to ensure processes have stopped
      pause:
        seconds: 5
        
    - name: Check that port 10250 is free
      shell: |
        if netstat -tulpn 2>/dev/null | grep -q 10250 || ss -tulpn | grep -q 10250; then
          echo "Port 10250 is still in use"
          fuser -k 10250/tcp || true
          exit 1
        else
          echo "Port 10250 is free"
          exit 0
        fi
      register: port_check
      ignore_errors: true

    - name: Load join data from control host
      slurp:
        src: "{{ join_data_file }}"
      register: join_data_encoded
      delegate_to: localhost
      become: false
      when: join_data_file is defined

    - name: Decode join data
      set_fact:
        join_data: "{{ join_data_encoded['content'] | b64decode }}"

    - name: Extract join command
      set_fact:
        join_command: "{{ join_data | regex_search('JOIN_COMMAND:(.*)$', '\\1') | first }}"

    - name: Display join command
      debug:
        msg: "Will execute: {{ join_command }}"

    - name: Configure network settings for optimal Kubernetes operation
      shell: |
        # Configure bridge netfilter settings
        cat > /etc/sysctl.d/99-kubernetes-cri.conf << EOF
        net.bridge.bridge-nf-call-iptables = 1
        net.bridge.bridge-nf-call-ip6tables = 1
        net.ipv4.ip_forward = 1
        EOF
        
        # Apply settings immediately
        sysctl --system
        
        # Ensure correct DNS resolution
        cat > /etc/resolv.conf << EOF
        nameserver 8.8.8.8
        nameserver 8.8.4.4
        EOF

        # Update hosts file to ensure proper node resolution
        grep -q "192.168.1.100" /etc/hosts || echo "192.168.1.100 kubernetes" >> /etc/hosts
        grep -q "192.168.1.80" /etc/hosts || echo "192.168.1.80 k8s-node-1" >> /etc/hosts
        grep -q "192.168.1.81" /etc/hosts || echo "192.168.1.81 k8s-node-2" >> /etc/hosts
        grep -q "192.168.1.82" /etc/hosts || echo "192.168.1.82 k8s-node-3" >> /etc/hosts

        # Test connectivity to the API server load balancer
        echo "Testing API server connectivity..."
        timeout 5 bash -c "cat < /dev/null > /dev/tcp/192.168.1.100/6443" && echo "API server is reachable on port 6443" || echo "Failed to connect to API server"
      ignore_errors: true
    
    - name: Restart containerd and kubelet services
      systemd:
        name: "{{ item }}"
        state: restarted
        daemon_reload: yes
      with_items:
        - containerd
        - kubelet
      ignore_errors: true
      
    - name: Join control plane with extended timeout
      shell: |
        # Create time file to track kubelet restart
        echo "$(date)" > /tmp/kubelet-restart-time
        
        # Run join command with extended timeout
        timeout 600 {{ join_command }} --ignore-preflight-errors=Port-10250,FileAvailable--etc-kubernetes-kubelet.conf,DirAvailable--var-lib-etcd --v=5
      register: join_result
      ignore_errors: true
      
    - name: Display join result
      debug:
        var: join_result
        verbosity: 0
      
    - name: Wait for kubelet to start if join was successful
      pause:
        seconds: 30
      when: join_result is success
      
    - name: Check kubelet status
      shell: systemctl status kubelet || true
      register: kubelet_status
      changed_when: false
      
    - name: Display kubelet status
      debug:
        var: kubelet_status.stdout_lines
        
    - name: Verify API server pod is running
      shell: |
        if [ -f /etc/kubernetes/manifests/kube-apiserver.yaml ]; then
          echo "API server manifest exists"
          
          # Check if pod is running
          if [ -d /etc/kubernetes/manifests/ ] && [ "$(ls -A /etc/kubernetes/manifests/)" ]; then
            echo "Manifests directory has files"
          else
            echo "Manifests directory is empty"
          fi
        else
          echo "API server manifest does not exist"
        fi
      register: apiserver_check
      
    - name: Display API server status
      debug:
        var: apiserver_check.stdout_lines
        
    - name: Create kube config directory for user
      file:
        path: "/home/{{ ansible_user }}/.kube"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      when: join_result is success
      
    - name: Copy kubeconfig to user directory
      copy:
        src: /etc/kubernetes/admin.conf
        dest: "/home/{{ ansible_user }}/.kube/config"
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      ignore_errors: true
      when: join_result is success
